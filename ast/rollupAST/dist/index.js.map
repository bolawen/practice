{"version":3,"sources":["../src/utils.ts","../src/tokenizer.ts","../src/node-types.ts","../src/parser.ts","../src/index.ts"],"sourcesContent":["// 分隔符\nexport function isWhiteSpace(char: string): boolean {\n  return char === \" \" || char === \"\\t\" || char === \"\\n\" || char === \"\\r\";\n}\n\n// 字母\nexport function isAlpha(char: string): boolean {\n  return (char >= \"a\" && char <= \"z\") || (char >= \"A\" && char <= \"Z\");\n}\n\n// 数字\nexport function isDigit(char: string): boolean {\n  return char >= \"0\" && char <= \"9\";\n}\n\n// 下划线\nexport function isUnderline(char: string): boolean {\n  return char === \"_\";\n}\n","import { isWhiteSpace, isAlpha, isDigit, isUnderline } from \"./utils\";\n\nexport enum TokenType {\n  Let = \"Let\",\n  Const = \"Const\",\n  Var = \"Var\",\n  Assign = \"Assign\",\n  Function = \"Function\",\n  Number = \"Number\",\n  Operator = \"Operator\",\n  Identifier = \"Identifier\",\n  LeftParen = \"LeftParen\",\n  RightParen = \"RightParen\",\n  LeftCurly = \"LeftCurly\",\n  RightCurly = \"RightCurly\",\n  Comma = \"Comma\",\n  Dot = \"Dot\",\n  Semicolon = \"Semicolon\",\n  StringLiteral = \"StringLiteral\",\n  Return = \"Return\",\n  Import = \"Import\",\n  Export = \"Export\",\n  Default = \"Default\",\n  From = \"From\",\n  As = \"As\",\n  Asterisk = \"Asterisk\",\n}\n\nexport enum ScanMode {\n  Normal,\n  Identifier,\n  StringLiteral,\n  Number,\n}\n\nexport type Token = {\n  type: TokenType;\n  value?: string;\n  start: number;\n  end: number;\n  raw?: string;\n};\n\n// 策略模式\nconst TOKENS_GENERATOR: Record<string, (...args: any[]) => Token> = {\n  let(start: number) {\n    return { type: TokenType.Let, value: \"let\", start, end: start + 3 };\n  },\n  const(start: number) {\n    return { type: TokenType.Const, value: \"const\", start, end: start + 5 };\n  },\n  var(start: number) {\n    return { type: TokenType.Var, value: \"var\", start, end: start + 3 };\n  },\n  assign(start: number) {\n    return { type: TokenType.Assign, value: \"=\", start, end: start + 1 };\n  },\n  import(start: number) {\n    return {\n      type: TokenType.Import,\n      value: \"import\",\n      start,\n      end: start + 6,\n    };\n  },\n  export(start: number) {\n    return {\n      type: TokenType.Export,\n      value: \"export\",\n      start,\n      end: start + 6,\n    };\n  },\n  from(start: number) {\n    return {\n      type: TokenType.From,\n      value: \"from\",\n      start,\n      end: start + 4,\n    };\n  },\n  as(start: number) {\n    return {\n      type: TokenType.As,\n      value: \"as\",\n      start,\n      end: start + 2,\n    };\n  },\n  asterisk(start: number) {\n    return {\n      type: TokenType.Asterisk,\n      value: \"*\",\n      start,\n      end: start + 1,\n    };\n  },\n  default(start: number) {\n    return {\n      type: TokenType.Default,\n      value: \"default\",\n      start,\n      end: start + 7,\n    };\n  },\n  number(start: number, value: string) {\n    return {\n      type: TokenType.Number,\n      value,\n      start,\n      end: start + value.length,\n      raw: value,\n    };\n  },\n  function(start: number) {\n    return {\n      type: TokenType.Function,\n      value: \"function\",\n      start,\n      end: start + 8,\n    };\n  },\n  return(start: number) {\n    return {\n      type: TokenType.Return,\n      value: \"return\",\n      start,\n      end: start + 6,\n    };\n  },\n  operator(start: number, value: string) {\n    return {\n      type: TokenType.Operator,\n      value,\n      start,\n      end: start + value.length,\n    };\n  },\n  comma(start: number) {\n    return {\n      type: TokenType.Comma,\n      value: \",\",\n      start,\n      end: start + 1,\n    };\n  },\n  leftParen(start: number) {\n    return { type: TokenType.LeftParen, value: \"(\", start, end: start + 1 };\n  },\n  rightParen(start: number) {\n    return { type: TokenType.RightParen, value: \")\", start, end: start + 1 };\n  },\n  leftCurly(start: number) {\n    return { type: TokenType.LeftCurly, value: \"{\", start, end: start + 1 };\n  },\n  rightCurly(start: number) {\n    return { type: TokenType.RightCurly, value: \"}\", start, end: start + 1 };\n  },\n  dot(start: number) {\n    return { type: TokenType.Dot, value: \".\", start, end: start + 1 };\n  },\n  semicolon(start: number) {\n    return { type: TokenType.Semicolon, value: \";\", start, end: start + 1 };\n  },\n  stringLiteral(start: number, value: string, raw: string) {\n    return {\n      type: TokenType.StringLiteral,\n      value,\n      start,\n      end: start + value.length + 2,\n      raw,\n    };\n  },\n  identifier(start: number, value: string) {\n    return {\n      type: TokenType.Identifier,\n      value,\n      start,\n      end: start + value.length,\n    };\n  },\n};\n\ntype SingleCharTokens = \"(\" | \")\" | \"{\" | \"}\" | \".\" | \";\" | \",\" | \"*\" | \"=\";\n\nconst KNOWN_SINGLE_CHAR_TOKENS = new Map<\n  SingleCharTokens,\n  typeof TOKENS_GENERATOR[keyof typeof TOKENS_GENERATOR]\n>([\n  [\"(\", TOKENS_GENERATOR.leftParen],\n  [\")\", TOKENS_GENERATOR.rightParen],\n  [\"{\", TOKENS_GENERATOR.leftCurly],\n  [\"}\", TOKENS_GENERATOR.rightCurly],\n  [\".\", TOKENS_GENERATOR.dot],\n  [\";\", TOKENS_GENERATOR.semicolon],\n  [\",\", TOKENS_GENERATOR.comma],\n  [\"*\", TOKENS_GENERATOR.asterisk],\n  [\"=\", TOKENS_GENERATOR.assign],\n]);\n\nconst QUOTATION_TOKENS = [\"'\", '\"', \"`\"];\n\nconst OPERATOR_TOKENS = [\n  \"+\",\n  \"-\",\n  \"*\",\n  \"/\",\n  \"%\",\n  \"^\",\n  \"&\",\n  \"|\",\n  \"~\",\n  \"<<\",\n  \">>\",\n];\n\nexport class Tokenizer {\n  private _tokens: Token[] = [];\n  private _currentIndex: number = 0;\n  private _source: string;\n  private _scanMode = ScanMode.Normal;\n  constructor(input: string) {\n    this._source = input;\n  }\n\n  scanIndentifier(): void {\n    this._setScanMode(ScanMode.Identifier);\n    // 继续扫描，直到收集完整的单词\n    let identifier = \"\";\n    let currentChar = this._getCurrentChar();\n    const startIndex = this._currentIndex;\n    while (\n      isAlpha(currentChar) ||\n      isDigit(currentChar) ||\n      isUnderline(currentChar)\n    ) {\n      identifier += currentChar;\n      this._currentIndex++;\n      currentChar = this._getCurrentChar();\n    }\n    let token;\n    // 1. 结果为关键字\n    if (identifier in TOKENS_GENERATOR) {\n      token =\n        TOKENS_GENERATOR[identifier as keyof typeof TOKENS_GENERATOR](\n          startIndex\n        );\n    }\n    // 2. 结果为标识符\n    else {\n      token = TOKENS_GENERATOR[\"identifier\"](startIndex, identifier);\n    }\n    this._tokens.push(token);\n    this._resetScanMode();\n  }\n\n  scanStringLiteral(): void {\n    this._setScanMode(ScanMode.StringLiteral);\n    const startIndex = this._currentIndex;\n    let currentChar = this._getCurrentChar();\n    // 记录引号\n    const startQuotation = currentChar;\n    // 继续找字符串\n    this._currentIndex++;\n    let str = \"\";\n    currentChar = this._getCurrentChar();\n    while (currentChar && currentChar !== startQuotation) {\n      str += currentChar;\n      this._currentIndex++;\n      currentChar = this._getCurrentChar();\n    }\n    const token = TOKENS_GENERATOR.stringLiteral(\n      startIndex,\n      str,\n      `${startQuotation}${str}${startQuotation}`\n    );\n    this._tokens.push(token);\n    this._resetScanMode();\n  }\n\n  _scanNumber(): void {\n    this._setScanMode(ScanMode.Number);\n    const startIndex = this._currentIndex;\n    let number = \"\";\n    let currentChar = this._getCurrentChar();\n    let isFloat = false;\n    // 如果是数字，则继续扫描\n    // 需要考虑到小数点\n    while (isDigit(currentChar) || (currentChar === \".\" && !isFloat)) {\n      if (currentChar === \".\") {\n        isFloat = true;\n      }\n      number += currentChar;\n      this._currentIndex++;\n      currentChar = this._getCurrentChar();\n    }\n    if (isFloat && currentChar === \".\") {\n      throw new Error('Unexpected character \".\"');\n    }\n    const token = TOKENS_GENERATOR.number(startIndex, number);\n    this._tokens.push(token);\n    this._resetScanMode();\n  }\n\n  tokenize(): Token[] {\n    // 扫描\n    while (this._currentIndex < this._source.length) {\n      let currentChar = this._source[this._currentIndex];\n      const startIndex = this._currentIndex;\n      // 1. 判断是否是分隔符\n      if (isWhiteSpace(currentChar)) {\n        this._currentIndex++;\n        continue;\n      }\n      // 2. 判断是否是字母\n      else if (isAlpha(currentChar)) {\n        this.scanIndentifier();\n        continue;\n      }\n      // 3. 判断是否是单字符 () {} . ; *\n      else if (KNOWN_SINGLE_CHAR_TOKENS.has(currentChar as SingleCharTokens)) {\n        // * 字符特殊处理\n        if (currentChar === \"*\") {\n          // 前瞻，如果是非 import/export，则认为是二元运算符，避免误判\n          const previousToken = this._getPreviousToken();\n          if (\n            previousToken.type !== TokenType.Import &&\n            previousToken.type !== TokenType.Export\n          ) {\n            this._tokens.push(\n              TOKENS_GENERATOR.operator(startIndex, currentChar)\n            );\n            this._currentIndex++;\n            continue;\n          }\n          // 否则按照 import/export 中的 * 处理\n        }\n        const token = KNOWN_SINGLE_CHAR_TOKENS.get(\n          currentChar as SingleCharTokens\n        )!(startIndex);\n        this._tokens.push(token);\n        this._currentIndex++;\n      }\n      // 4. 判断是否为引号\n      else if (QUOTATION_TOKENS.includes(currentChar)) {\n        this.scanStringLiteral();\n        // 跳过结尾的引号\n        this._currentIndex++;\n        continue;\n      }\n      // 5. 判断二元计算符\n      else if (\n        OPERATOR_TOKENS.includes(currentChar) &&\n        this._scanMode === ScanMode.Normal\n      ) {\n        this._tokens.push(TOKENS_GENERATOR.operator(startIndex, currentChar));\n        this._currentIndex++;\n        continue;\n      } else if (\n        OPERATOR_TOKENS.includes(currentChar + this._getNextChar()) &&\n        this._scanMode === ScanMode.Normal\n      ) {\n        this._tokens.push(\n          TOKENS_GENERATOR.operator(\n            startIndex,\n            currentChar + this._getNextChar()\n          )\n        );\n        this._currentIndex += 2;\n        continue;\n      }\n      // 6. 判断数字\n      else if (isDigit(currentChar)) {\n        this._scanNumber();\n        continue;\n      }\n    }\n    this._resetCurrentIndex();\n    return this._getTokens();\n  }\n\n  private _getCurrentChar() {\n    return this._source[this._currentIndex];\n  }\n\n  private _getNextChar() {\n    if (this._currentIndex + 1 < this._source.length) {\n      return this._source[this._currentIndex + 1];\n    }\n    return \"\";\n  }\n\n  private _resetCurrentIndex() {\n    this._currentIndex = 0;\n  }\n\n  private _getTokens() {\n    return this._tokens;\n  }\n\n  private _getPreviousToken() {\n    // 前瞻 Token\n    if (this._tokens.length > 0) {\n      return this._tokens[this._tokens.length - 1];\n    }\n    throw new Error(\"Previous token not found\");\n  }\n\n  private _setScanMode(mode: ScanMode) {\n    this._scanMode = mode;\n  }\n\n  private _resetScanMode() {\n    this._scanMode = ScanMode.Normal;\n  }\n}\n","export enum NodeType {\n  Program = \"Program\",\n  VariableDeclaration = \"VariableDeclaration\",\n  FunctionDeclaration = \"FunctionDeclaration\",\n  Identifier = \"Identifier\",\n  BlockStatement = \"BlockStatement\",\n  ExpressionStatement = \"ExpressionStatement\",\n  ReturnStatement = \"ReturnStatement\",\n  CallExpression = \"CallExpression\",\n  BinaryExpression = \"BinaryExpression\",\n  MemberExpression = \"MemberExpression\",\n  FunctionExpression = \"FunctionExpression\",\n  Literal = \"Literal\",\n  ImportDeclaration = \"ImportDeclaration\",\n  ImportSpecifier = \"ImportSpecifier\",\n  ImportDefaultSpecifier = \"ImportDefaultSpecifier\",\n  ImportNamespaceSpecifier = \"ImportNamespaceSpecifier\",\n  ExportDeclaration = \"ExportDeclaration\",\n  ExportSpecifier = \"ExportSpecifier\",\n  ExportDefaultDeclaration = \"ExportDefaultDeclaration\",\n  ExportNamedDeclaration = \"ExportNamedDeclaration\",\n  ExportAllDeclaration = \"ExportAllDeclaration\",\n  VariableDeclarator = \"VariableDeclarator\",\n}\n\nexport enum FunctionType {\n  FunctionDeclaration,\n  CallExpression,\n}\n\nexport interface Node {\n  type: string;\n  start: number;\n  end: number;\n}\n\nexport interface Program extends Node {\n  type: NodeType.Program;\n  body: Statement[];\n}\n\nexport interface Literal extends Node {\n  type: NodeType.Literal;\n  value: string;\n  raw: string;\n}\n\nexport interface Identifier extends Node {\n  type: NodeType.Identifier;\n  name: string;\n}\n\nexport interface CallExpression extends Node {\n  type: NodeType.CallExpression;\n  callee: Expression;\n  arguments: Expression[];\n}\n\nexport interface MemberExpression extends Node {\n  type: NodeType.MemberExpression;\n  object: Identifier | MemberExpression;\n  property: Identifier;\n  computed: boolean;\n}\n\nexport interface BlockStatement extends Node {\n  type: NodeType.BlockStatement;\n  body: Statement[];\n}\n\nexport interface ExpressionStatement extends Node {\n  type: NodeType.ExpressionStatement;\n  expression: Expression;\n}\n\nexport interface FunctionExpression extends FunctionNode {\n  type: NodeType.FunctionExpression;\n}\n\nexport interface FunctionDeclaration extends FunctionNode {\n  type: NodeType.FunctionDeclaration;\n  id: Identifier | null;\n}\n\nexport type VariableKind = \"var\" | \"let\" | \"const\";\n\nexport interface VariableDeclarator extends Node {\n  type: NodeType.VariableDeclarator;\n  id: Identifier;\n  init: Expression | Literal | null;\n}\n\nexport interface VariableDeclaration extends Node {\n  type: NodeType.VariableDeclaration;\n  kind: \"var\" | \"let\" | \"const\";\n  declarations: VariableDeclarator[];\n}\n\nexport interface ImportSpecifier extends Node {\n  type: NodeType.ImportSpecifier;\n  imported: Identifier;\n  local: Identifier;\n}\n\nexport interface ImportDefaultSpecifier extends Node {\n  type: NodeType.ImportDefaultSpecifier;\n  local: Identifier;\n}\n\nexport interface ImportNamespaceSpecifier extends Node {\n  type: NodeType.ImportNamespaceSpecifier;\n  local: Identifier;\n}\n\nexport type ImportSpecifiers =\n  | (ImportSpecifier | ImportDefaultSpecifier)[]\n  | ImportNamespaceSpecifier[];\n\nexport interface ImportDeclaration extends Node {\n  type: NodeType.ImportDeclaration;\n  specifiers: ImportSpecifiers;\n  source: Literal;\n}\n\nexport type Declaration =\n  | FunctionDeclaration\n  | VariableDeclaration\n  | ImportDeclaration\n  | ExportDeclaration\n  | VariableDeclarator;\n\nexport interface ExportSpecifier extends Node {\n  type: NodeType.ExportSpecifier;\n  exported: Identifier;\n  local: Identifier;\n}\n\nexport interface ExportNamedDeclaration extends Node {\n  type: NodeType.ExportNamedDeclaration;\n  declaration: Declaration | null;\n  specifiers: ExportSpecifier[];\n  source: Literal | null;\n}\n\nexport interface ExportDefaultDeclaration extends Node {\n  type: NodeType.ExportDefaultDeclaration;\n  declaration: Declaration | Expression;\n}\n\nexport interface ExportAllDeclaration extends Node {\n  type: NodeType.ExportAllDeclaration;\n  source: Literal;\n  exported: Identifier | null;\n}\n\nexport type ExportDeclaration =\n  | ExportNamedDeclaration\n  | ExportDefaultDeclaration\n  | ExportAllDeclaration;\n\nexport interface BinaryExpression extends Node {\n  type: NodeType.BinaryExpression;\n  left: Expression;\n  right: Expression;\n  operator: string;\n}\nexport interface FunctionNode extends Node {\n  id: Identifier | null;\n  params: Expression[] | Identifier[];\n  body: BlockStatement;\n}\n\nexport interface ReturnStatement extends Node {\n  type: NodeType.ReturnStatement;\n  argument: Expression;\n}\n\nexport type Statement =\n  | ImportDeclaration\n  | ExportDeclaration\n  | VariableDeclaration\n  | FunctionDeclaration\n  | ExpressionStatement\n  | BlockStatement\n  | ReturnStatement;\n\nexport type Expression =\n  | CallExpression\n  | MemberExpression\n  | Identifier\n  | Literal\n  | BinaryExpression\n  | FunctionExpression;\n","import { Token, TokenType } from \"./tokenizer\";\nimport {\n  BlockStatement,\n  CallExpression,\n  Expression,\n  ExpressionStatement,\n  FunctionDeclaration,\n  FunctionType,\n  Identifier,\n  ImportDeclaration,\n  ImportSpecifiers,\n  Literal,\n  MemberExpression,\n  NodeType,\n  Program,\n  Statement,\n  VariableDeclaration,\n  VariableDeclarator,\n  VariableKind,\n  ReturnStatement,\n  ExportSpecifier,\n  ExportDeclaration,\n  FunctionExpression,\n  BinaryExpression,\n} from \"./node-types\";\n\nexport class Parser {\n  private _tokens: Token[] = [];\n  private _currentIndex = 0;\n  constructor(token: Token[]) {\n    this._tokens = [...token];\n  }\n\n  parse(): Program {\n    const program = this._parseProgram();\n    return program;\n  }\n\n  private _parseProgram(): Program {\n    const program: Program = {\n      type: NodeType.Program,\n      body: [],\n      start: 0,\n      end: Infinity,\n    };\n    while (!this._isEnd()) {\n      const node = this._parseStatement();\n      program.body.push(node);\n      if (this._isEnd()) {\n        program.end = node.end;\n      }\n    }\n    return program;\n  }\n\n  private _parseStatement(): Statement {\n    if (this._checkCurrentTokenType(TokenType.Function)) {\n      return this._parseFunctionDeclaration() as FunctionDeclaration;\n    } else if (this._checkCurrentTokenType(TokenType.Identifier)) {\n      return this._parseExpressionStatement();\n    } else if (this._checkCurrentTokenType(TokenType.LeftCurly)) {\n      return this._parseBlockStatement();\n    } else if (this._checkCurrentTokenType(TokenType.Return)) {\n      return this._parseReturnStatement();\n    } else if (this._checkCurrentTokenType(TokenType.Import)) {\n      return this._parseImportStatement();\n    } else if (this._checkCurrentTokenType(TokenType.Export)) {\n      return this._parseExportStatement();\n    } else if (\n      this._checkCurrentTokenType([\n        TokenType.Let,\n        TokenType.Var,\n        TokenType.Const,\n      ])\n    ) {\n      return this._parseVariableDeclaration();\n    }\n    console.log(this._getCurrentToken());\n    throw new Error(\"Unexpected token\");\n  }\n\n  private _parseImportStatement(): ImportDeclaration {\n    const { start } = this._getCurrentToken();\n    const specifiers = [];\n    this._goNext(TokenType.Import);\n    // import a\n    if (this._checkCurrentTokenType(TokenType.Identifier)) {\n      const local = this._parseIdentifier();\n      const defaultSpecifier = {\n        type: NodeType.ImportDefaultSpecifier,\n        local,\n        start: local.start,\n        end: local.end,\n      };\n      specifiers.push(defaultSpecifier);\n      if (this._checkCurrentTokenType(TokenType.Comma)) {\n        this._goNext(TokenType.Comma);\n      }\n    }\n    // import { name1 }\n    if (this._checkCurrentTokenType(TokenType.LeftCurly)) {\n      this._goNext(TokenType.LeftCurly);\n      while (!this._checkCurrentTokenType(TokenType.RightCurly)) {\n        const specifier = this._parseIdentifier();\n        let local = null;\n        if (this._checkCurrentTokenType(TokenType.As)) {\n          this._goNext(TokenType.As);\n          local = this._parseIdentifier();\n        }\n        const importSpecifier = {\n          type: NodeType.ImportSpecifier,\n          imported: specifier,\n          local: local ? local : specifier,\n          start: specifier.start,\n          end: local ? local.end : specifier.end,\n        };\n        specifiers.push(importSpecifier);\n        if (this._checkCurrentTokenType(TokenType.Comma)) {\n          this._goNext(TokenType.Comma);\n        }\n      }\n      this._goNext(TokenType.RightCurly);\n    }\n    // import * as a\n    else if (this._checkCurrentTokenType(TokenType.Asterisk)) {\n      const { start } = this._getCurrentToken();\n      this._goNext(TokenType.Asterisk);\n      this._goNext(TokenType.As);\n      const local = this._parseIdentifier();\n      const importNamespaceSpecifier = {\n        type: NodeType.ImportNamespaceSpecifier,\n        local,\n        start,\n        end: local.end,\n      };\n      specifiers.push(importNamespaceSpecifier);\n    }\n\n    // from 'a'\n    if (this._checkCurrentTokenType(TokenType.From)) {\n      this._goNext(TokenType.From);\n    }\n    const source = this._parseLiteral();\n    const node: ImportDeclaration = {\n      type: NodeType.ImportDeclaration,\n      specifiers: specifiers as ImportSpecifiers,\n      start,\n      end: source.end,\n      source,\n    };\n    this._skipSemicolon();\n    return node;\n  }\n\n  private _parseExportStatement(): ExportDeclaration {\n    const { start } = this._getCurrentToken();\n    let exportDeclaration: ExportDeclaration | null = null;\n    const specifiers: ExportSpecifier[] = [];\n    this._goNext(TokenType.Export);\n    // export default\n    if (this._checkCurrentTokenType(TokenType.Default)) {\n      this._goNext(TokenType.Default);\n      // export default a\n      // export default obj.a\n      if (this._checkCurrentTokenType(TokenType.Identifier)) {\n        const local = this._parseExpression();\n        exportDeclaration = {\n          type: NodeType.ExportDefaultDeclaration,\n          declaration: local,\n          start: local.start,\n          end: local.end,\n        };\n      }\n      // export default function() {}\n      else if (this._checkCurrentTokenType(TokenType.Function)) {\n        const declaration = this._parseFunctionDeclaration();\n        exportDeclaration = {\n          type: NodeType.ExportDefaultDeclaration,\n          declaration,\n          start,\n          end: declaration.end,\n        };\n      }\n      // TODO: export default class {}\n      // TODO: export default { a: 1 };\n    }\n    // export {\n    else if (this._checkCurrentTokenType(TokenType.LeftCurly)) {\n      this._goNext(TokenType.LeftCurly);\n      while (!this._checkCurrentTokenType(TokenType.RightCurly)) {\n        const local = this._parseIdentifier();\n        let exported = local;\n        if (this._checkCurrentTokenType(TokenType.As)) {\n          this._goNext(TokenType.As);\n          exported = this._parseIdentifier();\n        }\n        const exportSpecifier: ExportSpecifier = {\n          type: NodeType.ExportSpecifier,\n          local,\n          exported,\n          start: local.start,\n          end: exported.end,\n        };\n        specifiers.push(exportSpecifier);\n        if (this._checkCurrentTokenType(TokenType.Comma)) {\n          this._goNext(TokenType.Comma);\n        }\n      }\n      this._goNext(TokenType.RightCurly);\n      if (this._checkCurrentTokenType(TokenType.From)) {\n        this._goNext(TokenType.From);\n      }\n      const source = this._parseLiteral();\n      exportDeclaration = {\n        type: NodeType.ExportNamedDeclaration,\n        specifiers,\n        start,\n        declaration: null,\n        end: source.end,\n        source,\n      };\n    }\n    // export const/let/var\n    else if (\n      this._checkCurrentTokenType([\n        TokenType.Const,\n        TokenType.Let,\n        TokenType.Var,\n      ])\n    ) {\n      const declaration = this._parseVariableDeclaration();\n      exportDeclaration = {\n        type: NodeType.ExportNamedDeclaration,\n        declaration,\n        start,\n        end: declaration.end,\n        specifiers: specifiers as ExportSpecifier[],\n        source: null,\n      };\n      return exportDeclaration;\n    }\n    // export function\n    else if (this._checkCurrentTokenType(TokenType.Function)) {\n      const declaration =\n        this._parseFunctionDeclaration() as FunctionDeclaration;\n      exportDeclaration = {\n        type: NodeType.ExportNamedDeclaration,\n        declaration,\n        start,\n        end: declaration.end,\n        specifiers: specifiers as ExportSpecifier[],\n        source: null,\n      };\n    }\n    // export * from 'mod'\n    else {\n      this._goNext(TokenType.Asterisk);\n      let exported: Identifier | null = null;\n      if (this._checkCurrentTokenType(TokenType.As)) {\n        this._goNext(TokenType.As);\n        exported = this._parseIdentifier();\n      }\n      this._goNext(TokenType.From);\n      const source = this._parseLiteral();\n      exportDeclaration = {\n        type: NodeType.ExportAllDeclaration,\n        start,\n        end: source.end,\n        source,\n        exported,\n      };\n    }\n    if (!exportDeclaration) {\n      throw new Error(\"Export declaration cannot be parsed\");\n    }\n    this._skipSemicolon();\n    return exportDeclaration!;\n  }\n\n  private _parseVariableDeclaration(): VariableDeclaration {\n    const { start } = this._getCurrentToken();\n    const kind = this._getCurrentToken().value;\n    this._goNext([TokenType.Let, TokenType.Var, TokenType.Const]);\n    const declarations = [];\n    const isVariableDeclarationEnded = (): boolean => {\n      if (this._checkCurrentTokenType(TokenType.Semicolon)) {\n        return true;\n      }\n      const nextToken = this._getNextToken();\n      // 往后看一个 token，如果是 =，则表示没有结束\n      if (nextToken && nextToken.type === TokenType.Assign) {\n        return false;\n      }\n      return true;\n    };\n    while (!isVariableDeclarationEnded()) {\n      const id = this._parseIdentifier();\n      let init = null;\n      if (this._checkCurrentTokenType(TokenType.Assign)) {\n        this._goNext(TokenType.Assign);\n        if (\n          this._checkCurrentTokenType([\n            TokenType.Number,\n            TokenType.StringLiteral,\n          ])\n        ) {\n          init = this._parseLiteral();\n        } else {\n          init = this._parseExpression();\n        }\n      }\n      const declarator: VariableDeclarator = {\n        type: NodeType.VariableDeclarator,\n        id,\n        init,\n        start: id.start,\n        end: init ? init.end : id.end,\n      };\n      declarations.push(declarator);\n      if (this._checkCurrentTokenType(TokenType.Comma)) {\n        this._goNext(TokenType.Comma);\n      }\n    }\n    const node: VariableDeclaration = {\n      type: NodeType.VariableDeclaration,\n      kind: kind as VariableKind,\n      declarations,\n      start,\n      end: this._getPreviousToken().end,\n    };\n    this._skipSemicolon();\n    return node;\n  }\n\n  private _parseReturnStatement(): ReturnStatement {\n    const { start } = this._getCurrentToken();\n    this._goNext(TokenType.Return);\n    const argument = this._parseExpression();\n    const node: ReturnStatement = {\n      type: NodeType.ReturnStatement,\n      argument,\n      start,\n      end: argument.end,\n    };\n    this._skipSemicolon();\n    return node;\n  }\n\n  private _parseExpressionStatement(): ExpressionStatement {\n    const expression = this._parseExpression();\n    const expressionStatement: ExpressionStatement = {\n      type: NodeType.ExpressionStatement,\n      expression,\n      start: expression.start,\n      end: expression.end,\n    };\n    return expressionStatement;\n  }\n\n  // 需要考虑 a.b.c 嵌套结构\n  private _parseExpression(): Expression {\n    // 先检查是否是一个函数表达式\n    if (this._checkCurrentTokenType(TokenType.Function)) {\n      return this._parseFunctionExpression();\n    }\n    if (\n      this._checkCurrentTokenType([TokenType.Number, TokenType.StringLiteral])\n    ) {\n      return this._parseLiteral();\n    }\n    // 拿到标识符，如 a\n    let expresion: Expression = this._parseIdentifier();\n    while (!this._isEnd()) {\n      if (this._checkCurrentTokenType(TokenType.LeftParen)) {\n        expresion = this._parseCallExpression(expresion);\n      } else if (this._checkCurrentTokenType(TokenType.Dot)) {\n        // 继续解析，a.b\n        expresion = this._parseMemberExpression(expresion as MemberExpression);\n      } else if (this._checkCurrentTokenType(TokenType.Operator)) {\n        // 解析 a + b\n        expresion = this.__parseBinaryOperatorExpression(expresion);\n      } else {\n        break;\n      }\n    }\n    return expresion;\n  }\n\n  private __parseBinaryOperatorExpression(\n    expression: Expression\n  ): BinaryExpression {\n    const { start } = this._getCurrentToken();\n    const operator = this._getCurrentToken().value!;\n    this._goNext(TokenType.Operator);\n    const right = this._parseExpression();\n    const node: BinaryExpression = {\n      type: NodeType.BinaryExpression,\n      operator,\n      left: expression,\n      right,\n      start,\n      end: right.end,\n    };\n    return node;\n  }\n\n  private _parseMemberExpression(\n    object: Identifier | MemberExpression\n  ): MemberExpression {\n    this._goNext(TokenType.Dot);\n    const property = this._parseIdentifier();\n    const node: MemberExpression = {\n      type: NodeType.MemberExpression,\n      object,\n      property,\n      start: object.start,\n      end: property.end,\n      computed: false,\n    };\n    return node;\n  }\n\n  private _parseCallExpression(callee: Expression) {\n    const args = this._parseParams(FunctionType.CallExpression) as Expression[];\n    // 获取最后一个字符的结束位置\n    const { end } = this._getPreviousToken();\n    const node: CallExpression = {\n      type: NodeType.CallExpression,\n      callee,\n      arguments: args,\n      start: callee.start,\n      end,\n    };\n    this._skipSemicolon();\n    return node;\n  }\n\n  private _parseFunctionDeclaration(): FunctionDeclaration {\n    const { start } = this._getCurrentToken();\n    this._goNext(TokenType.Function);\n    let id = null;\n    if (this._checkCurrentTokenType(TokenType.Identifier)) {\n      id = this._parseIdentifier();\n    }\n    const params = this._parseParams();\n    const body = this._parseBlockStatement();\n    const node: FunctionDeclaration = {\n      type: NodeType.FunctionDeclaration,\n      id,\n      params,\n      body,\n      start,\n      end: body.end,\n    };\n    return node;\n  }\n\n  private _parseFunctionExpression(): FunctionExpression {\n    const { start } = this._getCurrentToken();\n    this._goNext(TokenType.Function);\n    let id = null;\n    if (this._checkCurrentTokenType(TokenType.Identifier)) {\n      id = this._parseIdentifier();\n    }\n    const params = this._parseParams();\n    const body = this._parseBlockStatement();\n    const node: FunctionExpression = {\n      type: NodeType.FunctionExpression,\n      id,\n      params,\n      body,\n      start,\n      end: body.end,\n    };\n    return node;\n  }\n\n  private _parseParams(\n    mode: FunctionType = FunctionType.FunctionDeclaration\n  ): Identifier[] | Expression[] {\n    this._goNext(TokenType.LeftParen);\n    const params = [];\n    while (!this._checkCurrentTokenType(TokenType.RightParen)) {\n      let param =\n        mode === FunctionType.FunctionDeclaration\n          ? // 函数声明\n            this._parseIdentifier()\n          : // 函数调用\n            this._parseExpression();\n      params.push(param);\n      if (!this._checkCurrentTokenType(TokenType.RightParen)) {\n        this._goNext(TokenType.Comma);\n      }\n    }\n    this._goNext(TokenType.RightParen);\n    return params;\n  }\n\n  private _parseLiteral(): Literal {\n    const token = this._getCurrentToken();\n    let value: string | number | boolean = token.value!;\n    if (token.type === TokenType.Number) {\n      value = Number(value);\n    }\n    const literal: Literal = {\n      type: NodeType.Literal,\n      value: token.value!,\n      start: token.start,\n      end: token.end,\n      raw: token.raw!,\n    };\n    this._goNext(token.type);\n    return literal;\n  }\n\n  private _parseIdentifier(): Identifier {\n    const token = this._getCurrentToken();\n    const identifier: Identifier = {\n      type: NodeType.Identifier,\n      name: token.value!,\n      start: token.start,\n      end: token.end,\n    };\n    this._goNext(TokenType.Identifier);\n    return identifier;\n  }\n\n  private _parseBlockStatement(): BlockStatement {\n    const { start } = this._getCurrentToken();\n    const blockStatement: BlockStatement = {\n      type: NodeType.BlockStatement,\n      body: [],\n      start,\n      end: Infinity,\n    };\n    this._goNext(TokenType.LeftCurly);\n    while (!this._checkCurrentTokenType(TokenType.RightCurly)) {\n      const node = this._parseStatement();\n      blockStatement.body.push(node);\n    }\n    blockStatement.end = this._getCurrentToken().end;\n    this._goNext(TokenType.RightCurly);\n    return blockStatement;\n  }\n\n  private _checkCurrentTokenType(type: TokenType | TokenType[]): boolean {\n    if (this._isEnd()) {\n      return false;\n    }\n    const currentToken = this._tokens[this._currentIndex];\n    if (Array.isArray(type)) {\n      return type.includes(currentToken.type);\n    } else {\n      return currentToken.type === type;\n    }\n  }\n\n  private _skipSemicolon(): void {\n    if (this._checkCurrentTokenType(TokenType.Semicolon)) {\n      this._goNext(TokenType.Semicolon);\n    }\n  }\n\n  private _goNext(type: TokenType | TokenType[]): Token {\n    const currentToken = this._tokens[this._currentIndex];\n    // 断言当前 Token 的类型，如果不能匹配，则抛出错误\n    if (Array.isArray(type)) {\n      if (!type.includes(currentToken.type)) {\n        throw new Error(\n          `Expect ${type.join(\",\")}, but got ${currentToken.type}`\n        );\n      }\n    } else {\n      if (currentToken.type !== type) {\n        throw new Error(`Expect ${type}, but got ${currentToken.type}`);\n      }\n    }\n    this._currentIndex++;\n    return currentToken;\n  }\n\n  private _isEnd(): boolean {\n    return this._currentIndex >= this._tokens.length;\n  }\n\n  private _getCurrentToken(): Token {\n    return this._tokens[this._currentIndex];\n  }\n\n  private _getPreviousToken(): Token {\n    return this._tokens[this._currentIndex - 1];\n  }\n\n  private _getNextToken(): Token | false {\n    if (this._currentIndex + 1 < this._tokens.length) {\n      return this._tokens[this._currentIndex + 1];\n    } else {\n      return false;\n    }\n  }\n}\n","import { Parser } from \"./parser\";\nimport { Tokenizer } from \"./tokenizer\";\n\nexport function parse(code: string) {\n  const tokenizer = new Tokenizer(code);\n  const tokens = tokenizer.tokenize();\n  const parser = new Parser(tokens);\n  return parser.parse();\n}\n\nexport * from \"./tokenizer\";\nexport * from \"./node-types\";"],"mappings":"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","names":["TokenType","ScanMode","NodeType","FunctionType","start"]}